"""Utility rules used to compile Verilator"""

load("//dependency_support/org_gnu_bison:bison.bzl", "locate_bison_data_root")

def _verilator_astgen_impl(ctx):
    args = ctx.actions.args()
    args.add("--astgen", ctx.file.astgen)
    args.add_all(ctx.files.srcs, format_each = "--src=%s")
    args.add_all(ctx.outputs.outs, format_each = "--out=%s")
    args.add("--")
    args.add_all(ctx.attr.args)

    ctx.actions.run(
        executable = ctx.executable._process_wrapper,
        mnemonic = "VerilatorASTgen",
        arguments = [args],
        inputs = ctx.files.srcs,
        outputs = ctx.outputs.outs,
        tools = [ctx.file.astgen],
    )

    return [DefaultInfo(
        files = depset(ctx.outputs.outs),
    )]

verilator_astgen = rule(
    doc = "Run Verilator's `astgen` tool and collect the requested outputs.",
    implementation = _verilator_astgen_impl,
    attrs = {
        "args": attr.string_list(
            doc = "The command line arugments for `astgen`.",
        ),
        "astgen": attr.label(
            doc = "The path to the `astgen` tool.",
            allow_single_file = True,
            mandatory = True,
        ),
        "outs": attr.output_list(
            doc = "The output sources generated by `astgen`.",
            allow_empty = False,
            mandatory = True,
        ),
        "srcs": attr.label_list(
            doc = "Input sources for `astgen`.",
            allow_files = True,
        ),
        "_process_wrapper": attr.label(
            cfg = "exec",
            executable = True,
            default = Label("//dependency_support/verilator/private:verilator_astgen"),
        ),
    },
)

def _is_expandable(value):
    for prefix in ("$(execpath", "$(location"):
        if prefix in value:
            return True

    return False

def _verilator_bisonpre_impl(ctx):
    data = [ctx.attr.bisonpre] + ctx.attr.srcs + ctx.attr.tools
    args = ctx.actions.args()
    args.add(ctx.file.bisonpre)
    args.add_all([
        ctx.expand_location(a, data) if _is_expandable(a) else a
        for a in ctx.attr.args
    ])

    envs = {
        "BISON_PKGDATADIR": locate_bison_data_root(ctx.files.bison_data),
    }
    envs.update({
        # Expand $(location) / $(locations) in the values.
        k: ctx.expand_location(v, data) if _is_expandable(v) else v
        for k, v in ctx.attr.env.items()
    })
    ctx.actions.run(
        outputs = ctx.outputs.outs,
        inputs = ctx.files.srcs,
        tools = [ctx.file.bisonpre] + ctx.files.tools + ctx.files.bison_data,
        executable = ctx.executable._process_wrapper,
        arguments = [args],
        mnemonic = "VerilatorBisonPre",
        use_default_shell_env = False,
        env = envs,
    )
    return DefaultInfo(
        files = depset(ctx.outputs.outs),
        runfiles = ctx.runfiles(files = ctx.outputs.outs),
    )

verilator_bisonpre = rule(
    doc = "Run Verilator's `bisonpre` tool and collect the requested outputs.",
    implementation = _verilator_bisonpre_impl,
    attrs = {
        "args": attr.string_list(
            doc = "Command line arguments of the `bisonpre`",
        ),
        "bison_data": attr.label(
            doc = "Runtime data for GNU Bison.",
            allow_files = True,
            mandatory = True,
        ),
        "bisonpre": attr.label(
            doc = "The path to the `bisonpre` tool.",
            allow_single_file = True,
            mandatory = True,
            cfg = "exec",
        ),
        "env": attr.string_dict(
            doc = "Environment variables of the action.",
        ),
        "outs": attr.output_list(
            mandatory = True,
            doc = "Output files generated by the action.",
        ),
        "srcs": attr.label_list(
            allow_files = True,
            doc = "Additional inputs of the action.",
        ),
        "tools": attr.label_list(
            allow_files = True,
            cfg = "exec",
            doc = "Additional tools of the action.",
        ),
        "_process_wrapper": attr.label(
            executable = True,
            cfg = "exec",
            default = Label("//dependency_support/verilator/private:verilator_bisonpre"),
        ),
    },
)

def _verilator_flexfix_impl(ctx):
    args = ctx.actions.args()
    args.add("--flexfix", ctx.file.flexfix)
    args.add("--src", ctx.file.src)
    args.add("--output", ctx.outputs.out)
    args.add("--")
    args.add_all(ctx.attr.args)

    ctx.actions.run(
        executable = ctx.executable._process_wrapper,
        mnemonic = "VerilatorFlexFix",
        outputs = [ctx.outputs.out],
        inputs = [ctx.file.src],
        tools = [ctx.file.flexfix],
        arguments = [args],
    )

    return [DefaultInfo(
        files = depset([ctx.outputs.out]),
    )]

verilator_flexfix = rule(
    doc = "Run Verilator's `flexfix` tool and collect the requested outputs.",
    implementation = _verilator_flexfix_impl,
    attrs = {
        "args": attr.string_list(
            doc = "The command line arugments for `flexfix`.",
        ),
        "flexfix": attr.label(
            doc = "The path to the `flexfix` tool.",
            cfg = "exec",
            allow_single_file = True,
            mandatory = True,
        ),
        "out": attr.output(
            doc = "The output source generated by `flexfix`.",
            mandatory = True,
        ),
        "src": attr.label(
            doc = "The source file to pass to `flexfix`.",
            mandatory = True,
            allow_single_file = True,
        ),
        "_process_wrapper": attr.label(
            cfg = "exec",
            executable = True,
            default = Label("//dependency_support/verilator/private:verilator_flexfix"),
        ),
    },
)

def _verilator_version_impl(ctx):
    output = ctx.actions.declare_file(ctx.label.name + ".txt")

    args = ctx.actions.args()
    args.add("--output", output)
    args.add("--changelog", ctx.file.changelog)

    ctx.actions.run(
        executable = ctx.executable._parser,
        mnemonic = "VerilatorVersion",
        outputs = [output],
        inputs = [ctx.file.changelog],
        arguments = [args],
    )

    return [DefaultInfo(
        files = depset([output]),
    )]

verilator_version = rule(
    doc = "A rule for parsing the current verilator version from the change log.",
    implementation = _verilator_version_impl,
    attrs = {
        "changelog": attr.label(
            doc = "The Verilator change log.",
            allow_single_file = True,
            mandatory = True,
        ),
        "_parser": attr.label(
            executable = True,
            cfg = "exec",
            default = Label("//dependency_support/verilator/private:verilator_version"),
        ),
    },
)

def _verilator_build_template_impl(ctx):
    output = ctx.outputs.out

    args = ctx.actions.args()
    args.add("--output", output)
    args.add("--version", ctx.file.version)
    args.add("--substitutions", json.encode(ctx.attr.substitutions))
    args.add("--template", ctx.file.template)

    ctx.actions.run(
        executable = ctx.executable._generator,
        mnemonic = "VerilatorBuildTemplate",
        outputs = [output],
        inputs = [ctx.file.version, ctx.file.template],
        arguments = [args],
    )

    return [DefaultInfo(
        files = depset([output]),
    )]

verilator_build_template = rule(
    doc = "A rule for expanding verilator template files required for compiling.",
    implementation = _verilator_build_template_impl,
    attrs = {
        "out": attr.output(
            doc = "The output file",
            mandatory = True,
        ),
        "substitutions": attr.string_dict(
            doc = "A mapping of substitutions to apply on the template file.",
            mandatory = True,
        ),
        "template": attr.label(
            doc = "The base template to apply substitutions to",
            mandatory = True,
            allow_single_file = True,
        ),
        "version": attr.label(
            doc = (
                "A file containing the current version of Verilator. In substitution " +
                "values, the `{VERILATOR_VERSION}` string will be replaced by the version " +
                "in this file."
            ),
            allow_single_file = True,
            mandatory = True,
        ),
        "_generator": attr.label(
            executable = True,
            cfg = "exec",
            default = Label("//dependency_support/verilator/private:verilator_build_template"),
        ),
    },
)
